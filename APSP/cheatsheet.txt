//core floyd warshall

long long INF = 4e18;

for (int k = 0; k < n; k++)
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      if (dist[i][k] < INF && dist[k][j] < INF)
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);


//initialization

dist[i][i] = 0;
dist[u][v] = min(dist[u][v], w); // directed


//mandatory nodes

--> MUST PASS THROUGH X
dist[u][X] + dist[X][v]

--> MUST PASS THROUGH X OR Y
min(dist[u][X] + dist[X][v],
    dist[u][Y] + dist[Y][v])


--> MUST PASS THROUGH X AND Y
min(
 dist[u][X] + dist[X][Y] + dist[Y][v],
 dist[u][Y] + dist[Y][X] + dist[X][v]
)


//RESTRICTED nodes
if (forbidden[k]) continue;

//LIMITED INTERMEDIATES
--> at most one intermediate
long long ans = dist[u][v];          // 0 intermediate
for (int k = 0; k < n; k++) {        // 1 intermediate
    ans = min(ans, dist[u][k] + dist[k][v]);
}


--> exactly 2 INTERMEDIATES
long long ans = INF;
for(int i=0;i<n;i++)
 for(int j=0;j<n;j++)
   ans = min(ans,
       dist[u][i] + dist[i][j] + dist[j][v]);


//DISCOUNTED CITY(C/2)

long long ans = dist[u][v]; // normal path

        if (dist[u][D] < INF && dist[D][v] < INF) {
            long long discounted = (dist[u][D] + dist[D][v]) / 2;
            ans = min(ans, discounted);
        }


//TEMPORARY ROAD PER QUERY
long long ans = dist[u][v];

if (dist[u][a] < INF && dist[b][v] < INF) {
    ans = min(ans, dist[u][a] + w + dist[b][v]);
}

if (ans >= INF) cout << -1;
else cout << ans;


//TEMPORARY ROAD REMOVED PER QUERY

// store original weight
long long old = dist[a][b];
dist[a][b] = INF;

// recompute APSP
floydWarshall(dist);

long long ans = dist[u][v];
if (ans >= INF) cout << -1;
else cout << ans;

// restore edge
dist[a][b] = old;


//GPT
https://chatgpt.com/c/69654a64-d964-8322-ac88-a278ea6f05be